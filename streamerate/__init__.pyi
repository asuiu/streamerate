# Type stub for streamerate
# Author: ASU --<andrei.suiu@gmail.com>

import io
from numbers import Real
from typing import (
    AbstractSet,
    Any,
    BinaryIO,
    Callable,
    Dict,
    Generator,
    Iterable,
    Iterator,
    List,
    Mapping,
    MutableSet,
    NoReturn,
    Optional,
    Set,
    Tuple,
    TypeVar,
    Union,
    overload,
)

_K = TypeVar("_K")
_K2 = TypeVar("_K2")
_V = TypeVar("_V")
_V2 = TypeVar("_V2")
_T = TypeVar("_T")
_T_co = TypeVar("_T_co", covariant=True)

class ItrFromFunc(Iterable[_K]):
    def __init__(self, f: Callable[[], Iterable[_K]]) -> None: ...
    def __iter__(self) -> Iterator[_K]: ...

class TqdmMapper:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __call__(self, el: _K) -> _K: ...

class stream(Iterable[_K]):
    def __init__(
        self,
        itr: Optional[Union[Iterable[_K], Iterator[_K], Callable[[], Iterable[_K]]]] = None,
    ) -> None: ...
    def __iter__(self) -> Iterator[_K]: ...
    def __reversed__(self) -> stream[_K]: ...
    @overload
    def __getitem__(self, i: slice) -> stream[_K]: ...
    @overload
    def __getitem__(self, i: int) -> _K: ...
    def __add__(self, other: Any) -> stream[_K]: ...
    def __iadd__(self, other: Any) -> stream[_K]: ...
    def map(self, f: Callable[[_K], _V]) -> stream[_V]: ...
    def starmap(self, f: Callable[[_K], _V]) -> stream[_V]: ...
    def mpmap(self, f: Callable[[_K], _V], poolSize: int = ..., bufferSize: Optional[int] = 1) -> stream[_V]: ...
    def mpstarmap(self, f: Callable[[_K], _V], poolSize: int = ..., bufferSize: Optional[int] = 1) -> stream[_V]: ...
    def mpfastmap(self, f: Callable[[_K], _V], poolSize: int = ..., bufferSize: Optional[int] = 1) -> stream[_V]: ...
    def mpfaststarmap(self, f: Callable[[_K], _V], poolSize: int = ..., bufferSize: Optional[int] = 1) -> stream[_V]: ...
    def fastmap(self, f: Callable[[_K], _V], poolSize: int = ..., bufferSize: Optional[int] = None) -> stream[_V]: ...
    def faststarmap(self, f: Callable[[_K], _V], poolSize: int = ..., bufferSize: Optional[int] = None) -> stream[_V]: ...
    def mtmap(self, f: Callable[[_K], _V], poolSize: int = ..., bufferSize: Optional[int] = None) -> stream[_V]: ...
    def mtstarmap(self, f: Callable[[_K], _V], poolSize: int = ..., bufferSize: Optional[int] = None) -> stream[_V]: ...
    def gtmap(self, f: Callable[[_K], _V], poolSize: int = ...) -> stream[_V]: ...
    def gtfastmap(self, f: Callable[[_K], _V], poolSize: int = ...) -> stream[_V]: ...
    def gtstarmap(self, f: Callable[[_K], _V], poolSize: int = ...) -> stream[_V]: ...
    @overload
    def fastFlatMap(
        self,
        predicate: Callable[[_K], Iterable[_V]],
        poolSize: int = ...,
        bufferSize: Optional[int] = None,
    ) -> stream[_V]: ...
    @overload
    def fastFlatMap(
        self,
        poolSize: int = ...,
        bufferSize: Optional[int] = None,
    ) -> stream[_K]: ...
    def fastFlatMap(
        self,
        predicate: Callable[[_K], Iterable[_V]] = ...,
        poolSize: int = ...,
        bufferSize: Optional[int] = None,
    ) -> stream[_V]: ...
    def map_stream(self, f: Callable[[stream[_K]], _T]) -> _T: ...
    def enumerate(self) -> stream[Tuple[int, _K]]: ...
    @overload
    def flatMap(
        self,
        predicate: Callable[[_K], Iterable[_V]],
    ) -> stream[_V]: ...
    @overload
    def flatMap(
        self,
    ) -> stream[_K]: ...
    def flatMap(self, predicate: Callable[[_K], Iterable[_V]] = ...) -> stream[_V]: ...
    def pairWith(self: stream[_K], f: Callable[[_K], _V]) -> stream[Tuple[_K, _V]]: ...
    def pairBy(self: stream[_V], f: Callable[[_V], _K]) -> stream[Tuple[_K, _V]]: ...
    def mapKeys(self: stream[Tuple[_K, _V]], f: Callable[[_K], _K2]) -> stream[Tuple[_K2, _V]]: ...
    def mapValues(self: stream[Tuple[_K, _V]], f: Callable[[_V], _V2]) -> stream[Tuple[_K, _V2]]: ...
    def filterKeys(self: stream[Tuple[_K, _V]], predicate: Callable[[_K], bool]) -> stream[Tuple[_K, _V]]: ...
    def filterValues(self: stream[Tuple[_K, _V]], predicate: Callable[[_V], bool]) -> stream[Tuple[_K, _V]]: ...
    def for_each(self, f: Callable[[_K], None]) -> None: ...
    def tap(self, f: Callable[[_K], Any]) -> stream[_K]: ...
    def add_observer(self, f: Callable[[_K], None]) -> stream[_K]: ...
    def filter(self, predicate: Optional[Callable[[_K], bool]] = None) -> stream[_K]: ...
    def starfilter(self, predicate: Callable[[_K], bool]) -> stream[_K]: ...
    def reversed(self) -> stream[_K]: ...
    def exists(self, f: Callable[[_K], bool]) -> bool: ...
    @overload
    def keyBy(self, keyfunc: Callable[[_K], _V]) -> stream[Tuple[_V, _K]]: ...
    def keyBy(self, keyfunc: Callable[[_K], _V] = ...) -> stream[Tuple[_V, _K]]: ...
    def keystream(self: stream[Tuple[_T, _V]]) -> stream[_T]: ...
    def values(self: stream[Tuple[_T, _V]]) -> stream[_V]: ...
    @overload
    def groupBy(self, keyfunc: Callable[[_K], _T]) -> slist[Tuple[_T, slist[_K]]]: ...
    @overload
    def groupBy(self) -> slist[Tuple[_K, slist[_K]]]: ...
    def groupBy(self, keyfunc: Callable[[_K], _T] = ...) -> slist[Tuple[_T, slist[_K]]]: ...
    @overload
    def group_consecutive(self, order_fn: Callable[[_K], _T]) -> stream[Tuple[_T, stream[_K]]]: ...
    @overload
    def group_consecutive(self) -> stream[Tuple[_K, stream[_K]]]: ...
    def group_consecutive(self, order_fn: Callable[[_K], _T] = ...) -> stream[Tuple[_T, stream[_K]]]: ...
    @overload
    def groupBySorted(self, keyfunc: Callable[[_K], _T]) -> stream[Tuple[_T, stream[_K]]]: ...
    @overload
    def groupBySorted(self) -> stream[Tuple[_K, stream[_K]]]: ...
    def groupBySorted(self, keyfunc: Optional[Callable[[_K], _T]] = None) -> stream[Tuple[_T, stream[_K]]]: ...
    @overload
    def groupBySortedToList(self, keyfunc: Callable[[_K], _T]) -> stream[Tuple[_T, slist[_K]]]: ...
    @overload
    def groupBySortedToList(self) -> stream[Tuple[_K, slist[_K]]]: ...
    def groupBySortedToList(self, keyfunc: Callable[[_K], _T] = ...) -> stream[Tuple[_T, slist[_K]]]: ...
    def countByValue(self) -> sdict[_K, int]: ...
    @overload
    def reduce(self, f: Callable[[_K, _K], _K], init: Optional[_K] = None) -> _K: ...
    @overload
    def reduce(self, f: Callable[[_T, _K], _T], init: _T = None) -> _T: ...
    @overload
    def reduce(self, f: Callable[[Union[_K, _T], _K], _T], init: Optional[_T] = None) -> _T: ...
    @overload
    def reduce(self, f: Callable[[Union[_K, _T], _K], _T], init: Optional[_K] = None) -> _T: ...
    def transform(self, f: Callable[[Iterable[_K]], Iterable[_V]]) -> stream[_V]: ...
    def shuffle(self, seed: Optional[Union[int, float, str, bytes, bytearray]] = None) -> slist[_K]: ...
    def toSet(self) -> sset[_K]: ...
    def toList(self) -> slist[_K]: ...
    def sorted(self, key: Any = None, reverse: bool = False) -> slist[_K]: ...
    def toMap(self: stream[Tuple[_T, _V]]) -> sdict[_T, _V]: ...
    def to_list(self) -> slist[_K]: ...
    def to_set(self) -> sset[_K]: ...
    def to_map(self: stream[Tuple[_T, _V]]) -> sdict[_T, _V]: ...
    def to_dict(self: stream[Tuple[_T, _V]]) -> sdict[_T, _V]: ...
    def toSumCounter(self: stream[Tuple[_T, _V]]) -> sdict[_T, _V]: ...
    def toDataFrame(self: stream[Dict[str, _V]], *args: Any, **kwargs: Any) -> Any: ...
    def size(self) -> int: ...
    def join(self, f: Optional[Callable[[_K], _V]] = None) -> Union[_K, str]: ...
    def mkString(self, c: str) -> str: ...
    def batch(self, size: int) -> stream[slist[_K]]: ...
    def take(self, n: int) -> stream[_K]: ...
    def takeWhile(self, predicate: Callable[[_K], bool]) -> stream[_K]: ...
    def drop(self, n: int) -> stream[_K]: ...
    def dropWhile(self, predicate: Callable[[_K], bool]) -> stream[_K]: ...
    def next(self) -> _K: ...
    def head(self, n: int) -> stream[_K]: ...
    def tail(self, n: int) -> stream[_K]: ...
    def all_equal(self) -> bool: ...
    def quantify(self, predicate: Callable[[_K], bool]) -> int: ...
    def pad_with(self, pad: Any) -> stream[Union[Any, _K]]: ...
    def roundrobin(self) -> stream[_K]: ...
    def sum(self) -> Real: ...
    @overload
    def min(self) -> _K: ...
    @overload
    def min(self, key: Callable[[_K], _V]) -> _K: ...
    @overload
    def min_default(self, default: _T) -> Union[_K, _T]: ...
    @overload
    def min_default(self, default: _T, key: Callable[[_K], _V]) -> Union[_K, _T]: ...
    @overload
    def max(self) -> _K: ...
    @overload
    def max(self, key: Callable[[_K], _V]) -> _K: ...
    @overload
    def maxes(self) -> slist[_K]: ...
    @overload
    def maxes(self, key: Callable[[_K], _V]) -> slist[_K]: ...
    @overload
    def mins(self) -> slist[_K]: ...
    @overload
    def mins(self, key: Callable[[_K], _V]) -> slist[_K]: ...
    def entropy(self) -> Real: ...
    def pstddev(self) -> float: ...
    def mean(self) -> float: ...
    def zip(self) -> stream[object]: ...
    def distinct(self, key: Optional[Callable[[_K], _V]] = None) -> stream[_K]: ...
    def unique(self, key: Optional[Callable[[_K], _V]] = None) -> stream[_K]: ...
    def product(self, repeat: Optional[int] = None) -> stream[Tuple[object, ...]]: ...
    def tqdm(
        self,
        desc: Optional[str] = None,
        total: Optional[int] = None,
        leave: bool = True,
        file: Optional[io.TextIOWrapper] = None,
        ncols: Optional[int] = None,
        mininterval: float = 0.1,
        maxinterval: float = 10.0,
        ascii: Optional[Union[str, bool]] = None,
        unit: str = "it",
        unit_scale: Optional[Union[bool, int, float]] = False,
        dynamic_ncols: Optional[bool] = False,
        smoothing: Optional[float] = 0.3,
        initial: int = 0,
        position: Optional[int] = None,
        postfix: Optional[Dict[Any, Any]] = None,
        gui: bool = False,
        **kwargs: Any,
    ) -> stream[_K]: ...
    def throttle(self, max_req: int, interval: float) -> stream[_K]: ...
    @staticmethod
    def binaryToChunk(binaryData: bytes) -> bytes: ...
    def dumpToPickle(self, fileStream: BinaryIO) -> None: ...
    def dumpPickledToWriter(self, writer: Callable[[bytes], _T]) -> None: ...
    @staticmethod
    def _picklePack(el: Any) -> bytes: ...
    def exceptIndexes(self, *indexes: int) -> stream[_K]: ...
    @staticmethod
    def readFromBinaryChunkStream(
        readStream: BinaryIO,
        format: str = "<L",
        statHandler: Optional[Callable[[int, int], None]] = None,
    ) -> stream[object]: ...
    @staticmethod
    def loadFromPickled(
        file: BinaryIO,
        format: str = "<L",
        statHandler: Optional[Callable[[int, int], None]] = None,
    ) -> stream[object]: ...

class AbstractSynchronizedBufferedStream(stream[_K]):
    def __init__(self) -> None: ...
    def __next__(self) -> _K: ...
    def __iter__(self) -> Iterator[_K]: ...
    def _getNextBuffer(self) -> Iterable[_K]: ...

class buffered_stream(AbstractSynchronizedBufferedStream[_T]):
    def __init__(self, buffers: Iterable[Iterable[_T]]) -> None: ...
    def _getNextBuffer(self) -> Iterable[_T]: ...

class sset(set[_K], MutableSet[_K], stream[_K]):
    def __init__(self, *args: Any, **kwrds: Any) -> None: ...
    def __iter__(self) -> Iterator[_K]: ...
    def __reversed__(self) -> NoReturn: ...
    def __or__(self, s: AbstractSet[_V]) -> Set[Union[_K, _V]]: ...
    def __and__(self, other: AbstractSet[object]) -> sset[_K]: ...
    def __sub__(self, s: AbstractSet[object]) -> sset[_K]: ...
    def __xor__(self, s: AbstractSet[_V]) -> sset[Union[_K, _V]]: ...
    def update(self, *args: Any, **kwargs: Any) -> sset[_K]: ...  # type: ignore[override]
    def intersection_update(self, *args: Any, **kwargs: Any) -> sset[_K]: ...  # type: ignore[override]
    def difference_update(self, *args: Any, **kwargs: Any) -> sset[_K]: ...  # type: ignore[override]
    def symmetric_difference_update(self, *args: Any, **kwargs: Any) -> sset[_K]: ...  # type: ignore[override]
    def clear(self, *args: Any, **kwargs: Any) -> sset[_K]: ...  # type: ignore[override]
    def remove(self, *args: Any, **kwargs: Any) -> sset[_K]: ...  # type: ignore[override]
    def add(self, *args: Any, **kwargs: Any) -> sset[_K]: ...  # type: ignore[override]
    def discard(self, *args: Any, **kwargs: Any) -> sset[_K]: ...  # type: ignore[override]
    def union(self, *s: Iterable[_V]) -> sset[Union[_K, _V]]: ...
    def intersection(self, *s: Iterable[object]) -> sset[_K]: ...
    def difference(self, *s: Iterable[_V]) -> sset[Union[_K, _V]]: ...
    def symmetric_difference(self, s: Iterable[_V]) -> sset[Union[_K, _V]]: ...
    def isdisjoint(self, other: Iterable[Any]) -> bool: ...
    def tqdm(
        self,
        desc: Optional[str] = None,
        total: Optional[int] = None,
        leave: bool = True,
        file: Optional[io.TextIOWrapper] = None,
        ncols: Optional[int] = None,
        mininterval: float = 0.1,
        maxinterval: float = 10.0,
        ascii: Optional[Union[str, bool]] = None,
        unit: str = "it",
        unit_scale: Optional[Union[bool, int, float]] = False,
        dynamic_ncols: Optional[bool] = False,
        smoothing: Optional[float] = 0.3,
        initial: int = 0,
        position: Optional[int] = None,
        postfix: Optional[Dict[Any, Any]] = None,
        gui: bool = False,
        **kwargs: Any,
    ) -> stream[_K]: ...

class slist(List[_K], stream[_K]):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, iterable: Iterable[_K]) -> None: ...
    @overload
    def __getitem__(self, item: slice) -> slist[_K]: ...
    @overload
    def __getitem__(self, item: int) -> _K: ...
    def __iadd__(self, other: List[_K]) -> slist[_K]: ...  # type: ignore
    def __add__(self, x: List[_K]) -> Union[stream[_K], slist[_K]]: ...  # type: ignore
    def extend(self, iterable: Iterable[_K]) -> slist[_K]: ...  # type: ignore[override]
    def append(self, x: _K) -> slist[_K]: ...  # type: ignore[override]
    def remove(self, x: _K) -> slist[_K]: ...  # type: ignore[override]
    def insert(self, i: int, x: _K) -> slist[_K]: ...  # type: ignore[override]
    def exceptIndexes(self, *indexes: int) -> stream[_K]: ...
    # Override methods that should return slist instead of stream
    def map(self, f: Callable[[_K], _V]) -> stream[_V]: ...  # Returns stream, not slist
    def filter(self, predicate: Optional[Callable[[_K], bool]] = None) -> stream[_K]: ...  # Returns stream, not slist
    def tqdm(
        self,
        desc: Optional[str] = None,
        total: Optional[int] = None,
        leave: bool = True,
        file: Optional[io.TextIOWrapper] = None,
        ncols: Optional[int] = None,
        mininterval: float = 0.1,
        maxinterval: float = 10.0,
        ascii: Optional[Union[str, bool]] = None,
        unit: str = "it",
        unit_scale: Optional[Union[bool, int, float]] = False,
        dynamic_ncols: Optional[bool] = False,
        smoothing: Optional[float] = 0.3,
        initial: int = 0,
        position: Optional[int] = None,
        postfix: Optional[Dict[Any, Any]] = None,
        gui: bool = False,
        **kwargs: Any,
    ) -> stream[_K]: ...

class sdict(Dict[_K, _V], stream[_K]):
    def __init__(self, *args: Any, **kwrds: Any) -> None: ...
    def __iter__(self) -> Iterator[_K]: ...
    def __reversed__(self) -> NoReturn: ...
    def keys(self) -> stream[_K]: ...
    def values(self) -> stream[_V]: ...
    def items(self) -> stream[Tuple[_K, _V]]: ...
    def update(self, other: Any = None, **kwargs: Any) -> sdict[_K, _V]: ...
    def copy(self) -> sdict[_K, _V]: ...
    def tqdm(
        self,
        desc: Optional[str] = None,
        total: Optional[int] = None,
        leave: bool = True,
        file: Optional[io.TextIOWrapper] = None,
        ncols: Optional[int] = None,
        mininterval: float = 0.1,
        maxinterval: float = 10.0,
        ascii: Optional[Union[str, bool]] = None,
        unit: str = "it",
        unit_scale: Optional[Union[bool, int, float]] = False,
        dynamic_ncols: Optional[bool] = False,
        smoothing: Optional[float] = 0.3,
        initial: int = 0,
        position: Optional[int] = None,
        postfix: Optional[Dict[Any, Any]] = None,
        gui: bool = False,
        **kwargs: Any,
    ) -> stream[_K]: ...

class defaultstreamdict(sdict[_K, _V]):
    def __init__(self, default_factory: Optional[Callable[[], _V]] = None, *a: Any, **kw: Any) -> None: ...
    def __getitem__(self, key: _K) -> _V: ...
    def __missing__(self, key: _K) -> _V: ...
    def __reduce__(self) -> Tuple[type, Tuple, None, None, Iterator]: ...
    def copy(self) -> Mapping[_K, _V]: ...
    def __copy__(self) -> defaultstreamdict[_K, _V]: ...
    def __deepcopy__(self, memo: Any) -> defaultstreamdict[_K, _V]: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...

def smap(f: Callable[[_K], _V], itr: Iterable[_K]) -> stream[_V]: ...
def sfilter(f: Callable[[_K], bool], itr: Iterable[_K]) -> stream[_K]: ...
def iter_except(
    func: Callable[[], _K],
    exc: type[Exception],
    first: Optional[Callable[[], _K]] = None,
) -> Generator[_K, None, None]: ...

__all__ = [
    "stream",
    "slist",
    "sset",
    "sdict",
    "defaultstreamdict",
    "smap",
    "sfilter",
    "iter_except",
    "TqdmMapper",
    "AbstractSynchronizedBufferedStream",
    "buffered_stream",
]
